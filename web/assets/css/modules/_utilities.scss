/// Return a dark color or a light color based on the color given. This function can be used
/// when wanting to dynamically set the font-color based on the background color.
///
/// @param {Color} $color
///   The background color you want to get a font color for
///
/// @return {Hex} A light color for a dark background or a dark color for a light background

@function set-text-from-color($color) {
    // Not perfectly 50% because it's not perfectly split
    @if (lightness($color) > 54) {
        @return darken($color, 50%); // Lighter background, return dark color
    }
    @else {
        @return #ffffff; // Darker background, return light color
    }
}


/// Create a Block Element following the BEM naming scheme
///
/// @param {String} $element
///   Element's name

@mixin element($element) {
    &__#{$element} {
        @content;
    }
}


/// Create a Block Modifier following the BEM naming scheme
///
/// @param {String} $modifier
///   Modifier's name

@mixin modifier($modifier) {
    &--#{$modifier} {
        @content;
    }
}


//
// These CSS namespaces and descriptions come from CSS Wizardry
//
// http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/
//


/// Objects abstract out the repetitive, shared, and purely structural aspects of a UI into
/// reusable objects. This means that things like layout, wrappers and containers, the Media
/// Object, etc. can all exist as non-cosmetic styles that handle the skeletal aspect of a lot
/// of UI components, without ever actually looking like designed ‘things’.
///
/// @param {String} $name
///   Object's name

@mixin object($name) {
    .o-#{$name} {
        @content;
    }
}


/// Components are finite, discrete, implementation-specific parts of our UI that most people
/// (users, designers, developers, the business) would be able to identify: This is a button;
/// This is the date picker; etc.
///
/// @param {String} $name
///   Component's name

@mixin component($name) {
    .c-#{$name} {
        @content;
    }
}


/// Utilities are complete single responsibility rules which have a very specific and targeted
/// task. It is also quite common for these rules’ declarations to carry !important so as to
/// guarantee they beat other less specific ones. They do one thing in a very heavy-handed and
/// inelegant way. They are to be used as a last resort when no other CSS hooks are available,
/// or to tackle completely unique circumstances, e.g. using .u-text-center to centrally align
/// one piece of text once and once only. They are only one step away from inline styles, so
/// should be used sparingly.
///
/// @param {String} $name
///   Utility's name

@mixin utility($name) {
    .u-#{$name} {
        @content;
    }
}


/// When we work with Stateful Themes (that is to say, themes that we toggle on and off) we normally
/// do so by adding a class to the body element. Examples of this approach to theming include style-
/// switchers (a user can toggle between different themes) and sub-sections of a site (all blog posts
/// have one theme colour, all news pages have another theme colour, etc.). We simply add a class high
/// up the DOM which then invokes that theme for that particular page.
///
/// @param {String} $name
///   Theme's name

@mixin theme($name) {
    .t-#{$name} & {
        @content;
    }
}


/// Scoped contexts in CSS solve a very specific and particular problem: please be entirely certain
/// that you actually have this problem before employing Scopes, because they can be misused and end
/// up leading to actively bad CSS.
///
/// Oftentimes it can be useful to set up a brand new styling context for a particular section of your
/// UI. A perfect example of this is areas of user-generated content, where some long-form/prose HTML
/// has come from a CMS. The styling of this kind of content usually differs from the more app-like UI
/// around it. You may have a class-heavy UI architecture to provide complex pieces of design like
/// navigations, buttons, modals, etc., and inside all of this you may have a simple blog post which is
/// populated via a CMS where the user writes plain text and cannot add any classes or complexity.
///
/// @param {String} $name
///   Scope's name

@mixin scope($name) {
    .s-#{$name} {
        @content;
    }
}


/// Short-lived or temporary states of the UI that need styling accordingly.
///
/// When looking at a piece of interactive UI (e.g. a modal overlay) through developer tools, we’ll probably
/// spend some time toggling things on and off. Being able to see classes like .is-open appear and disappear
/// in the DOM is a highly readable and very obvious way of learning about state
///
/// @param {String} $name
///   State's name

@mixin is($name) {
    &.is-#{$name} {
        @content;
    }
}


/// @see {mixin} is
///
/// @param {String} $name
///   State's name

@mixin has($name) {
    &.has-#{$name} {
        @content;
    }
}


/// JavaScript namespaces are pretty common now, and most people tend to use them. The idea is that—in order
/// to properly separate our concerns—we should never have styling and behaviour bound to the same hooks. To
/// bind both technologies onto the same hook means we can’t have one without the other: our UI becomes all-
/// or-nothing, which makes it very opinionated and inflexible.
///
/// @param {String} $name
///   Javascript class' name

@mixin javascript($name) {
    .js-#{$name} {
        @content;
    }
}